\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename forge.info
@settitle Forge User and Developer Manual
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@copying
@quotation
Copyright (C) 2018-2022 Jonas Bernoulli <jonas@@bernoul.li>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU
General Public License for more details.

@end quotation
@end copying

@dircategory Emacs
@direntry
* Forge: (forge).       Access Git Forges from Magit.
@end direntry

@finalout
@titlepage
@title Forge User and Developer Manual
@subtitle for version 0.3.2-git
@author Jonas Bernoulli
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Forge User and Developer Manual

Forge allows you to work with Git forges, such as Github and Gitlab,
from the comfort of Magit and the rest of Emacs.

@noindent
This manual is for Forge version 0.3.2-git.

@quotation
Copyright (C) 2018-2022 Jonas Bernoulli <jonas@@bernoul.li>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU
General Public License for more details.

@end quotation
@end ifnottex

@menu
* Introduction::
* Supported Forges and Hosts::
* Getting Started::
* Usage::
* Other Options::
* FAQ::
* Keystroke Index::
* Function and Command Index::
* Variable Index::

@detailmenu
--- The Detailed Node Listing ---

Supported Forges and Hosts

* Supported Forges::
* Partially Supported Forges::
* Supported Semi-Forges::

Getting Started

* Token Creation::
* Initial Pull::
* Repository Detection::
* Caveats::

Usage

* Pulling::
* Branching::
* Working with Topics::
* Miscellaneous::

Working with Topics

* Visiting Topics::
* Listing Topics and Notifications::
* Creating Topics::
* Editing Topics and Posts::


FAQ

* Is it possible to create a single pull-request without pulling everything?::
* @code{error in process filter HTTP Error 502, "Bad gateway"}: @code{error in process filter HTTP Error 502 "Bad gateway"}. 

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

Forge allows you to work with Git forges, such as Github and Gitlab,
from the comfort of Magit and the rest of Emacs.

Forge fetches issues, pull-requests and other data using the forge's
API and stores that in a local database.  Additionally it fetches the
pull-request references using Git.  Forge implements various features
that use this data but the database and pull-request refs can also be
used by third-party packages.

@node Supported Forges and Hosts
@chapter Supported Forges and Hosts

Currently Forge supports two forges and three more forges partially.
Additionally it supports four semi-forges.  Support for more forges
and semi-forges can and will be added.

Both forges and semi-forges provide web interfaces for Git
repositories.  Forges additionally support pull-requests and issues
and make those and other information available using an API@.

When a forge is only partially supported, then that means that only
the functionality that does not require the API is implemented, or
in other words, that the forge is only supported as a semi-forge.

A host is a particular instance of a forge.  For example the hosts
@uref{https://gitlab.com} and @uref{https://salsa.debian.org} are both instances of
the Gitlab forge.  Forge supports some well known hosts out of the box
and additional hosts can easily be supported by adding entries to the
option @code{forge-alist}.

For more details about the caveats mentioned below (and some others)
also see @ref{Getting Started}.

@menu
* Supported Forges::
* Partially Supported Forges::
* Supported Semi-Forges::
@end menu

@node Supported Forges
@section Supported Forges

@anchor{Github}
@subheading Github

Forge's support for Github can be considered the "reference
  implementation".  Support for other forges can lag behind a bit.

@anchor{Github Caveats}
@subsubheading Github Caveats

@itemize
@item
Forge uses the Github GraphQL API when possible but has to fall
back to use the REST API in many cases because the former is still
rather incomplete.

@item
Forge depends on the @code{updated_at} field being updated when
appropriate.  For Github pull-requests at least, that is not always
done.
@end itemize

@anchor{Github Hosts}
@subsubheading Github Hosts

@itemize
@item
@uref{https://github.com}
@end itemize

@anchor{Gitlab}
@subheading Gitlab

@anchor{Gitlab Caveats}
@subsubheading Gitlab Caveats

@itemize
@item
Forge cannot provide notifications because the Gitlab API does not
expose those.
@end itemize

@anchor{Gitlab Hosts}
@subsubheading Gitlab Hosts

@itemize
@item
@uref{https://gitlab.com}
@item
@uref{https://salsa.debian.org}
@item
@uref{https://framagit.org}
@end itemize

@node Partially Supported Forges
@section Partially Supported Forges

@anchor{Gitea https//giteaio}
@subheading Gitea https://gitea.io

This is the next forge whose API will be supported.

@anchor{Gitea Hosts}
@subsubheading Gitea Hosts

@itemize
@item
@uref{https://codeberg.org}
@end itemize

@anchor{Gogs https//gogsio}
@subheading Gogs https://gogs.io

Once Gitea is supported it should be fairly simple to support Gogs
too, because the former is a fork of the latter and the APIs seem to
still be very similar.

@anchor{Gogs Hosts}
@subsubheading Gogs Hosts

@itemize
@item
@uref{https://code.orgmode.org}
@end itemize

@anchor{Bitbucket https//bitbucketorg}
@subheading Bitbucket https://bitbucket.org

I don't plan to support Bitbucket's API any time soon, and it gets
less likely that I will every do it every time I look at it.

@anchor{Bitbucket Caveats}
@subsubheading Bitbucket Caveats

@itemize
@item
The API documentation is poor and initial tests indicated that the
implementation is buggy.

@item
Atlassian's offering contains two very distinct implementations
that are both called "Bitbucket".  Forge only supports the
implementation whose only instance is available at
@uref{https://bitbucket.org}, because I only have access to that.

@item
Unlike all other forges, Bitbucket does not expose pull-requests
as references in the upstream repository.  For that reason Forge
actually treats it as a semi-forge, not as forge whose API is not
supported yet.  This means that you cannot checkout pull-requests
locally.  There is little hope that this will ever get fixed; the
respective issue was opened six years ago and there has been no
progress since: @uref{https://bitbucket.org/site/master/issues/5814}.
@end itemize

@anchor{Bitbucket Hosts}
@subsubheading Bitbucket Hosts

@itemize
@item
@uref{https://bitbucket.org}
@end itemize

@node Supported Semi-Forges
@section Supported Semi-Forges

@anchor{Gitweb https//git-scmcom/docs/gitweb}
@subheading Gitweb https://git-scm.com/docs/gitweb

@anchor{Gitweb Caveats}
@subsubheading Gitweb Caveats

@itemize
@item
I could find only one public installation
(@uref{https://git.savannah.gnu.org}), which gives users the choice
between Gitweb and Cgit.  The latter seems more popular (not
just on this site).
@end itemize

@anchor{Cgit https//gitzx2c4com/cgit/about}
@subheading Cgit https://git.zx2c4.com/cgit/about

@anchor{Cgit Caveats}
@subsubheading Cgit Caveats

@itemize
@item
Different sites use different URL schemata and some of the bigger
sites use a fork.  For this reason Forge has to provide several
classes to support different variations of Cgit and you have to
look at their definitions to figure out which one is the correct
one for a particular installation.
@end itemize

@anchor{Cgit Hosts}
@subsubheading Cgit Hosts

@itemize
@item
@uref{https://git.savannah.gnu.org/cgit}
@item
@uref{https://git.kernel.org}
@item
@uref{https://repo.or.cz}
@end itemize

@anchor{Stgit https//codemadnessorg/git/stagit/file/READMEhtml}
@subheading Stgit https://codemadness.org/git/stagit/file/README.html

@anchor{Stgit Caveats}
@subsubheading Stgit Caveats

@itemize
@item
Stgit cannot show logs for branches beside "master".  For that
reason Forge takes users to a page listing the branches when they
request the log for a particular branch (even for "master" whose
log is just one click away from there).
@end itemize

@anchor{Stgit Hosts}
@subsubheading Stgit Hosts

@itemize
@item
@uref{https://git.suckless.org}
@end itemize

@anchor{Srht https//metasrht}
@subheading Srht https://meta.sr.ht

@anchor{Srht Caveats}
@subsubheading Srht Caveats

@itemize
@item
Srht cannot show logs for branches beside "master".  For that
reason Forge takes users to a page listing the branches when they
request the log for a particular branch (even for "master" whose
log is just one click away from there).
@end itemize

@anchor{Srht Hosts}
@subsubheading Srht Hosts

@itemize
@item
@uref{https://git.sr.ht}
@end itemize

@node Getting Started
@chapter Getting Started

Getting started using Forge should be fairly easy provided you take the
time to read the documentation.  First see @ref{Getting Started,,,ghub,}
from Ghub's manual.  Ghub is the library that Forge uses to
communicate with forge APIs.  While Ghub can be used independently of
Forge, its "Getting Started" part was written with Forge users in
mind.

Please begin reading in @ref{Getting Started,,,ghub,} and then come back
here and make sure to read the subsections.

Loading Magit doesn't cause Forge to be loaded automatically.  Adding
something like this to your init file takes care of this:

@lisp
(with-eval-after-load 'magit
  (require 'forge))
@end lisp

Or if you use @code{use-package}:

@lisp
(use-package forge
  :after magit)
@end lisp

@menu
* Token Creation::
* Initial Pull::
* Repository Detection::
* Caveats::
@end menu

@node Token Creation
@section Token Creation

Forge uses the Ghub package to access the APIs of supported Git
forges.  How this works and how to create and store a token is
documented in @ref{Getting Started,,,ghub,}.

Ghub used to provide a setup wizard, but that had to be removed for
reasons given in the manual just mentioned.  Nowadays there is no way
around reading the documentation and doing this manually I am afraid.

Forge requires the following token scopes.

@itemize
@item
For Github these scopes are required.

@itemize
@item
@code{repo} grants full read/write access to private and public
repositories.
@item
@code{user} grants access to profile information.
@item
@code{read:org} grants read-only access to organization membership.
@end itemize

More information about these and other scopes can be found at
@uref{https://docs.github.com/en/developers/apps/scopes-for-oauth-apps}.

@item
For Gitlab instances @code{api} is the only required scope.  It gives read
and write access to everything.  The Gitlab API provides more
fine-grained scopes for read-only access, but when any write access
at all is required, then it is all or nothing.
@end itemize

@node Initial Pull
@section Initial Pull

To start using Forge in a certain repository visit the Magit status
buffer for that repository and type @code{f n} (@code{forge-pull}).  Alternatively,
you can use @code{M-x forge-add-repository}, which makes it possible to add a
forge repository without pulling all topics and even without having to
clone the respective Git repository.

You must set up a token @strong{before} you can add the first repository.
See @ref{Token Creation}.

The first time @code{forge-pull} is run in a repository, an entry for that
repository is added to the database and a new value is added to the
Git variable @code{remote.<remote>.fetch}, which fetches all pull-requests.
(@code{+refs/pull/*/head:refs/pullreqs/*} for Github)

@code{forge-pull} then fetches topics and other information using the forge's
API and pull-request references using Git.

The initial fetch can take a while but most of that is done
asynchronously.  Storing the information in the database is done
synchronously though, so there can be a noticeable hang at the end.
Subsequent fetches are much faster.

Fetching issues from Github is much faster than fetching from other
forges because making a handful of GraphQL requests is much faster
than making hundreds of REST requests.

@node Repository Detection
@section Repository Detection

Ghub does @strong{not} associate a given local repository with a repository on
a forge.  The Forge package itself takes care of this.  In doing so it
ignores the Git variable @code{ghub.host} and other @code{*.host} variables used by
Ghub.  (But @code{github.user} and other variables used to specify the user
are honored).

Forge associates the local repository with a forge repository by first
determining which remote is associated with the upstream repository
and then looking that up in @code{forge-alist}.

If only one remote exists, then Forge uses that unconditionally.  To
reduce the number of support requests, this is even the case if the
Git variable @code{forge.remote} names another, non-existent, remote.

If several remotes exist, then a remote may be selected based on its
name.  Almost always we want to fetch the data associated with the
upstream repository, so that is what the logic described here tries to
achieve.  The convention is to name the upstream remote "origin", and
if that convention were universally followed, then things would be
trivial.  However many people name the upstream remote "upstream",
which also makes sense.

@quotation
Note, however, that even though a surprising number of people do just
that, it does not make any sense to use the name "origin" to refer to
a fork; not even to your own fork.  A fork is a @strong{copy} of the original,
"copy" is an antonym for "original", and the word "origin" is not only
closely related to but even contained in the word "original".  Naming
a fork the "origin" is at best extremely confusing.

@table @asis
@item copy
a thing made to be similar or identical to another.

@item original
the earliest form of something, from which copies may be
made.

@item origin
the point or place where something begins, arises, or is
derived.
@end table

@end quotation

If several remotes exist, then the following remote names are tried in
order and the first remote thus named that exists in the repository is
used.

@enumerate
@item
The value of the Git variable @code{forge.remote}, if set.  If the
variable has a value but no remote by the specified name exists,
then a warning is shown, but otherwise this conflict is ignored.
This behavior is arguably odd, but due to historic and pragmatic
reasons it is the least painful path forward.

@item
The remote named @code{upstream}, if it exists.

@item
The remote named @code{origin}, if it exists.
@end enumerate

The remote named "upstream" is preferred over the remote named
"origin" because the existence of the former strongly suggests that
the latter is either not used in this repository (in which case the
order does not matter) or else it is abused as the name of a fork (in
which case "upstream" must be preferred).

@defvar forge.remote
The value of this variable specifies the remote from which Forge
fetches data.  It is usually best to leave this unspecified and to
rely on the behavior described above.

If the remote has to be specified explicitly, then this should be
done locally, for a single repository.

Only ever set this globally, if you consistently use a certain name
to refer to the upstream repository and it isn't one of "upstream"
or "origin", and you @strong{never} use that name to refer to a repository
that does @strong{not} refer to the upstream repository.
@end defvar

@table @asis
@item @kbd{N r} (@code{forge-forge.remote})
@kindex N r
@findex forge-forge.remote
This command changes the value of the @code{forge.remote} Git variable in
the current repository.
@end table

If this variable is set, then Forge uses the remote by that name, if
it exists, the same way it may have used @code{origin} if the the variable
were undefined.  I.e. it does not fall through to try @code{origin} if no
remote by your chosen name exists.

Once the upstream remote has been determined, Forge looks it up in
@code{forge-alist}, using the host part of the URL as the key.  For example
the key for @code{git@@github.com:magit/forge.git} is @code{github.com}.

@node Caveats
@section Caveats

@itemize
@item
Fetched information is stored in a database.  The table schemata of
that database have not been finalized yet.  Until that has happened
it will occasionally have to be discarded.  That isn't such a huge
deal because for now the database does not contain any information
that cannot simply be fetched again, see @ref{Initial Pull}.

@item
Fetching is implemented under the assumption that the API can be
asked to list the things that have changed since we last checked.
Unfortunately the APIs are not bug-free, so this is not always the
case.  If in doubt, then re-fetch an individual topic to ensure it
is up-to-date using the command @code{forge-pull-topic}.

@item
Some other, forge-specific, caveats are mentioned in @ref{Supported Forges and Hosts}.
@end itemize

@node Usage
@chapter Usage

Once information has been pulled from a repository's forge for the
first time, Forge adds two additional sections, named "Pull requests"
and "Issues" to Magit's status buffer.  It is also possible to add a
repository to the local database without pulling all the data, which
is useful if you want to create a single pull-request.

@table @asis
@item @kbd{N a} (@code{forge-add-repository})
@kindex N a
@findex forge-add-repository
This command adds a repository to the database.

It offers to either pull topics (now and in the future) or to only
pull individual topics when the user invokes @code{forge-pull-topic}.
@end table

Some of Forge's commands are only bound when point is within one of
these sections but other commands are also available elsewhere in
Magit's status buffer and/or from Magit's transient commands.

@table @asis
@item @kbd{N} (@code{forge-dispatch})
@kindex N
@findex forge-dispatch
This prefix command is available in any Magit buffer and provides
access to several of the available Forge commands.  Most of these
commands are also bound elsewhere, but some are not.  See the
following sections for information about the available commands.

Throughout this manual you will find many bindings that begin with
@code{N}, but if you prefer to continue to use @code{forge-dispatch}'s older
binding you can substitute @code{'} for that.
@end table

@menu
* Pulling::
* Branching::
* Working with Topics::
* Miscellaneous::
@end menu

@node Pulling
@section Pulling

The commands that fetch forge data are available from the same
transient prefix command (@code{magit-fetch} on @code{f}) that is used to fetch Git
data.  If option @code{magit-pull-or-fetch} is non-nil, then they are also
available from the @code{magit-pull} transient (on @code{F}).

@table @asis
@item @kbd{f n} (@code{forge-pull})
@itemx @kbd{N f f}
@kindex f n
@kindex N f f
@findex forge-pull
This command uses a forge's API to fetch topics and other
information about the current repository and stores the fetched
information in the database.  It also fetches notifications for all
repositories from the same forge host.  (Currently this is limited
to Github.)  Finally it fetches pull-request references using Git.

After using this command for the first time in a given repository
the status buffer for that repository always lists the pull-requests
and issues.  See @ref{Initial Pull}.

@item @kbd{f N} (@code{forge-pull-notifications})
@itemx @kbd{N f n}
@kindex f N
@kindex N f n
@findex forge-pull-notifications
This command uses a forge's API to fetch all notifications from that
forge including, but not limited to, the notifications for the current
repository.

Fetching all notifications fetches associated topics even if you
have not started fetching @strong{all} topics for the respective repositories
(using @code{forge-pull}), but it does not cause the topics to be listed in
the status buffer of such "uninitialized" repositories.
@end table

Note how pulling data from a forge's API works the same way as pulling
Git data does; you do it explicitly when you want to see the work done
by others.

This is less disruptive, more reliable, and easier to understand than
if Forge did the pulling by itself at random intervals.  It might
however mean that you occasionally invoke a command expecting the most
recent data to be available and then have to abort to pull first.
The same can happen with Git, e.g. you might attempt to merge a branch
that you know exists but haven't actually pulled yet.

@table @asis
@item @kbd{N f t} (@code{forge-pull-topic})
@kindex N f t
@findex forge-pull-topic
This command uses a forge's API to fetch a single pull-request and
stores it in the database.

Normally you wouldn't want to pull a single pull-request by itself,
but due to a bug in the Github API you might sometimes have to do
so.

Fetching is implemented under the assumption that the API can be
asked to list the things that have changed since we last checked.
Unfortunately the APIs are not bug-free, so this is not always the
case.  If in doubt, then re-fetch an individual topic to ensure it
is up-to-date using the command @code{forge-pull-topic}.
@end table

@node Branching
@section Branching

Forge provides commands for creating and checking out a new branch or
work tree from a pull-request.  These commands are available from the
same transient prefix commands as the suffix commands used to create
and check out branches and work trees in a more generic fashion
(@code{magit-branch} on @code{b} and @code{magit-worktree} on @code{%}).

@table @asis
@item @kbd{b N} (@code{forge-branch-pullreq})
@kindex b N
@findex forge-branch-pullreq
This command creates and configures a new branch from a pull-request,
creating and configuring a new remote if necessary.

The name of the local branch is the same as the name of the remote
branch that you are being asked to merge, unless the contributor
could not be bothered to properly name the branch before opening the
pull-request.  The most likely such case is when you are being asked
to merge something like "fork/master" into "origin/master".  In such
cases the local branch will be named "pr-N", where @code{N} is the
pull-request number.

These variables are always set by this command:

@itemize
@item
@code{branch.<name>.pullRequest} is set to the pull-request number.
@item
@code{branch.<name>.pullRequestRemote} is set to the remote on which the
pull-request branch is located.
@item
@code{branch.<name>.pushRemote} is set to the same remote as
@code{branch.<name>.pullRequestRemote} if that is possible, otherwise
it is set to the upstream remote.
@item
@code{branch.<name>.description} is set to the pull-request title.
@item
@code{branch.<name>.rebase} is set to @code{true} because there should be no
merge commits among the commits in a pull-request.
@end itemize

This command also configures the upstream and the push-remote of the
local branch that it creates.

The branch against which the pull-request was opened is always used
as the upstream.  This makes it easy to see what commits you are
being asked to merge in the section titled something like "Unmerged
into origin/master".

Like for other commands that create a branch, it depends on the
option @code{magit-branch-prefer-remote-upstream} whether the remote branch
itself or the respective local branch is used as the upstream, so
this section may also be titled e.g. "Unmerged into master".

When necessary and possible, the remote pull-request branch is
configured to be used as the push-target.  This makes it easy to see
what further changes the contributor has made since you last
reviewed their changes in the section titled something like
"Unpulled from origin/new-feature" or "Unpulled from
fork/new-feature".

@itemize
@item
If the pull-request branch is located in the upstream repository,
then you probably have set @code{remote.pushDefault} to that repository.
However some users like to set that variable to their personal
fork, even if they have push access to the upstream, so
@code{branch.<name>.pushRemote} is set anyway.

@item
If the pull-request branch is located inside a fork, then you are
usually able to push to that branch, because Github by default
allows the recipient of a pull-request to push to the remote
pull-request branch even if it is located in a fork.  The
contributor has to explicitly disable this.

@itemize
@item
If you are not allowed to push to the pull-request branch on
the fork, then a branch by the same name located in the
upstream repository is configured as the push-target.

@item
A—sadly rather common—special case is when the contributor
didn't bother to use a dedicated branch for the pull-request.

The most likely such case is when you are being asked to merge
something like "fork/master" into "origin/master".  The special
push permission mentioned above is never granted for the branch
that is the repository's default branch, and that would almost
certainly be the case in this scenario.

To enable you to easily push somewhere anyway, the local branch
is named "pr-N" (where @code{N} is the pull-request number) and the
upstream repository is used as the push-remote.

@item
Finally, if you are allowed to push to the pull-request branch
and the contributor had the foresight to use a dedicated branch,
then the fork is configured as the push-remote.
@end itemize

The push-remote is configured using @code{branch.<name>.pushRemote}, even
if the used value is identical to that of @code{remote.pushDefault}, just
in case you change the value of the latter later on.  Additionally
the variable @code{branch.<name>.pullRequestRemote} is set to the remote
on which the pull-request branch is located.
@end itemize

@item @kbd{b n} (@code{forge-checkout-pullreq})
@kindex b n
@findex forge-checkout-pullreq
This command creates and configures a new branch from a pull-request
the same way @code{forge-branch-pullreq} does.  Additionally it checks out
the new branch.

@item @kbd{Z n} (@code{forge-checkout-worktree})
@kindex Z n
@findex forge-checkout-worktree
This command creates and configures a new branch from a pull-request
the same way @code{forge-branch-pullreq} does.  Additionally it checks out
the new branch using a new working tree.

@item User Options: forge-checkout-worktree-read-directory-function
This function is used by @code{forge-checkout-worktree} to read read the
new worktree directory where it checks out to pull-request.  It
takes the pull-request as the only argument and must return a
directory.
@end table

When you delete a pull-request branch, which was created using one of
the above three commands, then @code{magit-branch-delete} usually offers to
also delete the corresponding remote.  It does not offer to delete a
remote if (1) the remote is the upstream remote, and/or (2) if other
branches are being fetched from the remote.

Note that you have to delete the local branch (e.g. "feature") for
this to work.  If you delete the tracking branch (e.g "fork/feature"),
then the remote is never removed.

@node Working with Topics
@section Working with Topics

We call both issues and pull-requests "topics".  The contributions to
the conversation are called "posts".

@menu
* Visiting Topics::
* Listing Topics and Notifications::
* Creating Topics::
* Editing Topics and Posts::
@end menu

@node Visiting Topics
@subsection Visiting Topics

Magit's status buffer contains lists of issues and pull-requests.
Topics are ordered by last modification time.  All open issues and
some recently edited and closed topics are listed.

Forge provides some commands that act on the listed topics.  These
commands can also be used in other contexts, such as when point is
on a commit or branch section.

@table @asis
@item @kbd{C-c C-w} (@code{forge-browse-TYPE})
@itemx @kbd{C-c C-w} (@code{forge-browse-dwim})
@itemx @kbd{N b r} (@code{forge-browse-remote})
@itemx @kbd{N b I} (@code{forge-browse-issues})
@itemx @kbd{N b P} (@code{forge-browse-pullreqs})
@itemx @kbd{N b t} (@code{forge-browse-topic})
@itemx @kbd{N b i} (@code{forge-browse-issue})
@itemx @kbd{N b p} (@code{forge-browse-pullreq})
@kindex C-c C-w
@kindex C-c C-w
@kindex N b r
@kindex N b I
@kindex N b P
@kindex N b t
@kindex N b i
@kindex N b p
@findex forge-browse-TYPE
@findex forge-browse-dwim
@findex forge-browse-remote
@findex forge-browse-issues
@findex forge-browse-pullreqs
@findex forge-browse-topic
@findex forge-browse-issue
@findex forge-browse-pullreq
These commands visit the topic, issue(s), pull-request(s), post,
branch, commit, or remote at point in a browser.

This is implemented using various commands named @code{forge-browse-TYPE},
and the key binding is defined by remapping @code{magit-browse-thing} (as
defined in @code{magit-mode-map)}.  For commit sections this key is bound
to @code{forge-browse-dwim}, which prefers a topic over a branch and a
branch over a commit.

@item @kbd{@key{RET}} (@code{forge-visit-TYPE})
@itemx @kbd{C-c C-v} (@code{forge-visit-topic})
@itemx @kbd{N v t} (@code{forge-visit-topic})
@itemx @kbd{N v i} (@code{forge-visit-issue})
@itemx @kbd{N v p} (@code{forge-visit-pullreq})
@kindex RET
@kindex C-c C-v
@kindex N v t
@kindex N v i
@kindex N v p
@findex forge-visit-TYPE
@findex forge-visit-topic
@findex forge-visit-issue
@findex forge-visit-pullreq
These commands visit the pull-request(s), issue(s), or repository in
a separate buffer.

The @code{RET} binding is only available when point is on a issue or
pull-request section because that key is already bound to something
else for most of Magit's own sections.  @code{C-c C-v} however is also
available on regular commit (e.g. in a log) and branch sections.

This is implemented using various commands named @code{forge-visit-TYPE}
and the key binding is defined by remapping @code{magit-visit-thing} (as
defined in @code{magit-mode-map}).
@end table

@node Listing Topics and Notifications
@subsection Listing Topics and Notifications

By default Forge lists a subset of topics directly in the Magit status
buffer.  It also provides commands to list topics and notifications in
separate buffers.

Forge adds the following two functions to @code{magit-status-sections-hook}:

@defun forge-insert-pullreqs
This function inserts a list of the most recent and/or open
pull-requests.
@end defun

@defun forge-insert-issues
This function inserts a list of the most recent and/or open issues.
@end defun

@defopt forge-topic-list-limit
This option limits the number of topics listed by the above
functions.

All unread topics are always shown.  If the value of this option has
the form @code{(OPEN . CLOSED)}, then the integer @code{OPEN} specifies the
maximal number of topics and @code{CLOSED} specifies the maximal number of
closed topics.  IF @code{CLOSED} is negative then show no closed topics
until the command @code{forge-toggle-closed-visibility} changes the sign.
@end defopt

@deffn Command forge-toggle-closed-visibility
This command toggles whether the above two functions list recently
closed issues in the current buffer.
@end deffn

The following three functions are also suitable for
@code{magit-status-sections-hook}:

@defun forge-insert-assigned-pullreqs
This function inserts a list of open pull-requests that are assigned
to you.
@end defun

@defun forge-insert-requested-reviews
This function inserts a list of open pull-requests that are awaiting
your review.
@end defun

@defun forge-insert-authored-pullreqs
This function inserts a list of open pull-requests that are authored
by you.
@end defun

@defun forge-insert-assigned-issues
This function inserts a list of open issues that are assigned to
you.
@end defun

@defun forge-insert-authored-issues
This function inserts a list of open issues that are authored by
you.
@end defun

The following commands list repositories, notifications and topics in
dedicated buffers:

@table @asis
@item @kbd{N l r} (@code{forge-list-repositories})
@kindex N l r
@findex forge-list-repositories
This command lists all known repositories in a separate buffer.

@item @kbd{N l n} (@code{forge-list-notifications})
@kindex N l n
@findex forge-list-notifications
This command lists all notifications for all forges in a separate
buffer.

@item @kbd{N l p} (@code{forge-list-pullreqs})
@kindex N l p
@findex forge-list-pullreqs
This command lists the current repository's pull-requests in a
separate buffer.

@item @kbd{N l i} (@code{forge-list-issues})
@kindex N l i
@findex forge-list-issues
This command lists the current repository's issues in a separate
buffer.
@end table

@deffn Command forge-list-labeled-pullreqs
This command lists the current repository's open pull-requests that
are labeled with a label read from the user.
@end deffn

@deffn Command forge-list-labeled-issues
This command lists the current repository's open issues that are
labeled with a label read from the user.
@end deffn

@deffn Command forge-list-assigned-pullreqs
This command lists the current repository's open pull-requests that
are assigned to you in a separate buffer.
@end deffn

@deffn Command forge-list-assigned-issues
This command lists the current repository's open issues that are
assigned to you in a separate buffer.
@end deffn

@deffn Command forge-list-requested-reviews
This command lists pull-requests of the current repository that are
awaiting your review in a separate buffer.
@end deffn

@deffn Command forge-list-authored-pullreqs
This command lists the current repository's open pull-requests that
are authored by you in a separate buffer.
@end deffn

@deffn Command forge-list-authored-issues
This command lists the current repository's open issues that are
authored by you in a separate buffer.
@end deffn

@deffn Command forge-list-owned-pullreqs
This command lists open pull-requests from all the repositories that
you own.  Options @code{forge-owned-accounts} and @code{forge-owned-ignored}
controls which repositories are considered to be owned by you.  Only
Github is supported for now.
@end deffn

@deffn Command forge-list-owned-issues
This command lists open issues from all the repositories that
you own.  Options @code{forge-owned-accounts} and @code{forge-owned-ignored}
controls which repositories are considered to be owned by you.  Only
Github is supported for now.
@end deffn

@defopt forge-owned-accounts
This is an alist of accounts that are owned by you.  This should
include your username as well as any organization that you own.
Used by the commands @code{forge-list-owned-issues},
@code{forge-list-owned-pullreqs} and @code{forge-fork}.

Each element has the form @code{(ACCOUNT . PLIST)}.  The following
properties are currently being used:

@itemize
@item
@code{remote-name} The default name suggested by @code{forge-fork} for a fork
created within this account.  If unspecified, then the name of the
account is used.
@end itemize

Example: @code{(("tarsius") ("emacsmirror" :remote-name "mirror"))}.
@end defopt

@defopt forge-owned-ignored
This is a list of repository names that are considered to not be
owned by you even though they would have been considered to be owned
by you based on @code{forge-owned-accounts}.
@end defopt

@node Creating Topics
@subsection Creating Topics

@table @asis
@item @kbd{N c p} (@code{forge-create-pullreq})
@itemx @kbd{C-c C-n [on "Pull requests" section]}
@kindex N c p
@kindex C-c C-n [on "Pull requests" section]
@findex forge-create-pullreq
This command creates a new pull-request for the current repository.

@item @kbd{N c i} (@code{forge-create-issue})
@itemx @kbd{C-c C-n [on "Issues" section]}
@kindex N c i
@kindex C-c C-n [on "Issues" section]
@findex forge-create-issue
This command creates a new issue for the current repository.
@end table

@node Editing Topics and Posts
@subsection Editing Topics and Posts

We call both issues and pull-requests "topics".  The contributions to
the conversation are called "posts".  The post that initiated the
conversation is also called a post.

These commands are available only from the topic buffer (i.e. from the
buffer that shows the posts on a topic).  Other commands that also
work in other buffers are available here also.  For example @code{C-c C-w} on
a post visits that post in a browser.

@table @asis
@item @kbd{C-c C-n} (@code{forge-create-post})
@itemx @kbd{C-c C-r}
@kindex C-c C-n
@kindex C-c C-r
@findex forge-create-post
This command allows users to create a new post on an existing topic.
It opens a buffer in which the user can write the post.  When the
post is done, then the user has to submit using @code{C-c C-c}.

If the region is active and marks part of an existing post, then
that part of the post is quoted.  Otherwise, or if a prefix argument
is used, then the complete post that point is currently on is quoted.

@item @kbd{C-c C-e [on a post section]} (@code{forge-edit-post})
@kindex C-c C-e [on a post section]
@findex forge-edit-post
This command visits an existing post in a separate buffer.  When the
changes to the post are done, then the user has to submit using @code{C-c
  C-c}.

@item @kbd{C-c C-e [on "Title" section]} (@code{forge-edit-topic-title})
@kindex C-c C-e [on "Title" section]
@findex forge-edit-topic-title
This command reads a new title for an existing topic in the
minibuffer.

@item @kbd{C-c C-e [on "State" section]} (@code{forge-edit-topic-state})
@kindex C-c C-e [on "State" section]
@findex forge-edit-topic-state
This command toggles the state of an existing topic between "open"
and "closed".

@item @kbd{C-c C-e [on "Labels" section]} (@code{forge-edit-topic-labels})
@kindex C-c C-e [on "Labels" section]
@findex forge-edit-topic-labels
This command reads a list of labels for an existing topic in the
minibuffer.

@item @kbd{C-c C-e [on "Marks" section]} (@code{forge-edit-topic-marks})
@kindex C-c C-e [on "Marks" section]
@findex forge-edit-topic-marks
This command reads a list of marks for an existing topic in the
minibuffer.

Marks are like labels except that they are not shared with anyone
else.  To create a mark that topics can subsequently be marked with
use the command @code{forge-create-mark}.  Existing marks can be edited
using the command @code{forge-edit-mark}.

@item @kbd{C-c C-e [on "Assignees" section]} (@code{forge-edit-topic-assignees})
@kindex C-c C-e [on "Assignees" section]
@findex forge-edit-topic-assignees
This command reads a list of assignees for an existing topic in the
minibuffer.

@item @kbd{C-c C-e [on "Review-Requests" section]} (@code{forge-edit-topic-review-requests})
@kindex C-c C-e [on "Review-Requests" section]
@findex forge-edit-topic-review-requests
This command reads a list of people who you would like to review an
existing topic in the minibuffer.

@item @kbd{C-c C-e [on "Note" section]}
@itemx @kbd{M-x forge-edit-topic-note}
@kindex C-c C-e [on "Note" section]
@findex forge-edit-topic-note
This lets you edit your private note about a topic.

@item @kbd{C-c C-k [on a comment section]} (@code{forge-delete-comment})
@kindex C-c C-k [on a comment section]
@findex forge-delete-comment
This command deletes the comment at point.

@item @kbd{m M [if enabled]} (@code{forge-merge})
@itemx @kbd{N M [if enabled]}
@kindex m M [if enabled]
@kindex N M [if enabled]
@findex forge-merge
This command merges the current pull-request using the forge's API@.
If there is no current pull-request or with a prefix argument, then
it reads a pull-request to visit instead.

The "merge method" to be used is read from the user.

Use of this command is discouraged.  Unless the remote repository is
configured to disallow that, you should instead merge locally and
then push the target branch.  Forges detect that you have done that
and respond by automatically marking the pull-request as merged.
@end table

Creating a new post and editing an existing post are similar to
creating a new commit and editing the message of an existing commit.
In both cases the message has to be written in a separate buffer and then
the process has to be finished or canceled using a separate command.

The following commands are available in buffers used to edit posts:

@table @asis
@item @kbd{C-c C-c} (@code{forge-post-submit})
@kindex C-c C-c
@findex forge-post-submit
This command submits the post that is being edited in the current
buffer.

@item @kbd{C-c C-k} (@code{forge-post-cancel})
@kindex C-c C-k
@findex forge-post-cancel
This command cancels the post that is being edited in the current
buffer.
@end table

@node Miscellaneous
@section Miscellaneous

@table @asis
@item @kbd{N c f} (@code{forge-fork})
@kindex N c f
@findex forge-fork
This command adds an additional remote to the current repository.
The remote can either point at an existing repository or one that
has to be created first by forking it to an account the user has
access to.

Currently this only supports Github and Gitlab.

@item @kbd{N a} (@code{forge-add-repository})
@kindex N a
@findex forge-add-repository
This command reads a repository from the user and adds it to the
database.  The repository can be provided as a URL, a name, or in
the form OWNER/NAME@.  This is subject to @code{magit-clone-name-alist}.

This command offers to either pull topics (now and in the future) or
to only pull individual topics when the user invokes
@code{forge-pull-topic}.

@item @kbd{N t t} (@code{forge-toggle-display-in-status-buffer})
@kindex N t t
@findex forge-toggle-display-in-status-buffer
This command toggles whether any topics are displayed in the current
Magit status buffer.

@item @kbd{N t c} (@code{forge-toggle-closed-visibility})
@kindex N t c
@findex forge-toggle-closed-visibility
This command toggles whether closed topics are shown in the Magit
status buffer.
@end table

@deffn Command forge-add-user-repositories
This command reads a host and a username from the user and adds all
of that user's repositories on that host to the local database.

This may take a while. Only Github is supported at the moment.
@end deffn

@deffn Command forge-add-organization-repositories
This command reads a host and an organization from the user and adds
all the organization's repositories on that host to the local database.

This may take a while. Only Github is supported at the moment.
@end deffn

@deffn Command forge-remove-repository
This command reads a repository and removes it from the local
database.
@end deffn

@deffn Command forge-remove-topic-locally
This command reads a topic and removes it from the local database.
The topic is not removed from the forge and, if it is later modified,
then it will be added to the database again.

Due to how the supported APIs work, it would be too expensive to
automatically remove topics from the local database that were removed
from the forge.  The only purpose of this command is to allow you to
manually clean up the local database.
@end deffn

@deffn Command forge-reset-database
This command moves the current database file to the trash and
creates a new empty database.

This is useful after the database's table schemata have changed,
which will happen a few times while the Forge functionality is still
under heavy development.
@end deffn

@node Other Options
@chapter Other Options

@defopt forge-database-connector
This option controls which database connector is used by Forge.

This must be set before @code{forge} is loaded.  To use an alternative
connector you must install the respective package explicitly.

@itemize
@item
When @code{sqlite}, then use the @code{emacsql-sqlite} library that is
being maintained in the same repository as @code{emacsql} itself.

@item
When @code{libsqlite3}, then use the @code{emacsql-libsqlite} library,
which itself uses a module provided by the @code{sqlite3} package.
This is still experimental.

@item
When @code{sqlite3}, then use the @code{emacsql-sqlite3} library, which
uses the official @code{sqlite3} command-line tool, which I do not
recommended because it is not suitable to be used like this,
but has the advantage that you likely don't need a compiler.
See @uref{https://nullprogram.com/blog/2014/02/06/}.
@end itemize
@end defopt

@node FAQ
@appendix FAQ

This section lists some frequently asked questions.  Please also see
@uref{https://github.com/magit/forge/wiki/FAQ} for an extended list of common
issues.

@menu
* Is it possible to create a single pull-request without pulling everything?::
* @code{error in process filter HTTP Error 502, "Bad gateway"}: @code{error in process filter HTTP Error 502 "Bad gateway"}. 
@end menu

@node Is it possible to create a single pull-request without pulling everything?
@appendixsec Is it possible to create a single pull-request without pulling everything?

Yes.  @code{M-x forge-add-repository} offers to add a repository to the
database without also fetching all pull-requests and issues.

@node @code{error in process filter HTTP Error 502 "Bad gateway"}
@appendixsec @code{error in process filter: HTTP Error: 502, "Bad gateway"}

This is a frequently occurring error.  Adding some formatting the full
error is:

@lisp
error in process filter: ghub--signal-error: HTTP Error: 502,
  "Bad gateway", "/graphql",
  ((data . "null")
   (errors ((message . "Something went wrong while executing your query.
      This may be the result of a timeout, or it could be a GitHub bug.
      Please include `CC2C:4FEA:A1771C1:CBF40CE:5C33F7E5`
      when reporting this issue."))))
@end lisp

This indicates that something went wrong within Github's network.  See
@uref{https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_server_errors}.
The appended error message also says as much: "This may be the result
of a timeout, or it could be a GitHub bug."

It appears that this happens more often in big repositories,
especially during the initial pull, but this may be an illusion; it is
known to also happens for smaller, incremental requests.

I believe that more data just means more requests and thus more
opportunities for things to go wrong.  It seems unlikely that this is
due to us requesting too much data at once (in that case we would get
a different error from GraphQL, not HTTP).  When fetching lots of
data, then we do not request one large response but make many requests
and we then collect the many responses (pagination forces us to do
that).

The timeout may be due to many requests from other people arriving at
some Github-internal bottleneck at the same time, or it may be due to
cold caches and overly aggressive timeouts.  We just don't know; it's
their infrastructure.

The second problem is that we currently simply error out if we get
this error.  This could be changed and eventually it will be, but for
the time being your only option is to just try again, possibly
repeatedly and possibly after a delay to give whatever congestion may
exist on the other end a chance to clear or to give their caches a
chance to warm up.

This was also discussed in @uref{https://github.com/magit/forge/issues/20} and
@uref{https://github.com/magit/ghub/issues/83}.

@node Keystroke Index
@appendix Keystroke Index

@printindex ky

@node Function and Command Index
@appendix Function and Command Index

@printindex fn

@node Variable Index
@appendix Variable Index

@printindex vr

@bye
